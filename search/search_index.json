{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"DRF payments","text":"<p>Package to handle various payments provider inside your drf project</p> <p>This package will allow you to create transactional payments on various payment providers:</p> <ul> <li>Stripe</li> <li>Paypal</li> <li>Braintree</li> <li>Authorize.net</li> </ul> <p>Upon creation of your app <code>Payment</code> model this library will handle:</p> <ul> <li>Creation of payment on selected provider</li> <li>Direct charge</li> <li>Checkout session</li> <li>Handling webhook event from payment gateway to update <code>Payment</code> status</li> <li>Handle Refund on the payment if payment was processed</li> <li>Write along the way all payment gateway responses in <code>extra_data</code> json field of your <code>Payment</code> model</li> </ul> <p>Installation - Installation guide</p> <p>Usage - Usage</p> <p>Constants - List of predefined constants</p> <p>DRF - Explanation of DRF integration</p> <p>For example of usage please see <code>example</code> app inside repository.</p>"},{"location":"constants/","title":"Constants","text":""},{"location":"constants/#payment-statuses","title":"Payment statuses","text":"<p>         Bases: <code>Enum</code></p> Source code in <code>drf_payments/constants.py</code> <pre><code>class PaymentStatus(Enum):\n    WAITING = \"waiting\"\n    PREAUTH = \"preauth\"\n    CONFIRMED = \"confirmed\"\n    REJECTED = \"rejected\"\n    REFUNDED = \"refunded\"\n    ERROR = \"error\"\n    INPUT = \"input\"\n</code></pre>"},{"location":"constants/#paymentcurrency","title":"PaymentCurrency","text":"<p>         Bases: <code>Enum</code></p> Source code in <code>drf_payments/constants.py</code> <pre><code>class PaymentCurrency(Enum):\n    CAD = \"cad\"\n    USD = \"usd\"\n    EUR = \"eur\"\n    GBP = \"gbp\"\n    AUD = \"aud\"\n    JPY = \"jpy\"\n    CHF = \"chf\"\n    HKD = \"hkd\"\n    NZD = \"nzd\"\n    SGD = \"sgd\"\n    SEK = \"sek\"\n    DKK = \"dkk\"\n    NOK = \"nok\"\n    MXN = \"mxn\"\n    BRL = \"brl\"\n    MYR = \"myr\"\n    PHP = \"php\"\n    THB = \"thb\"\n    IDR = \"idr\"\n    TRY = \"try\"\n    INR = \"inr\"\n    RUB = \"rub\"\n    ILS = \"ils\"\n    SAR = \"sar\"\n</code></pre>"},{"location":"drf/drf/","title":"DRF integration","text":"<p>For integrations with DRF we have couple of solutions. Feel free to inherit them and override to more precise fit your needs</p>"},{"location":"drf/drf/#paymentcallbackview","title":"PaymentCallbackView","text":"<p>View to handle webhooks from payment gateways</p> <p>         Bases: <code>generics.CreateAPIView</code></p> <p>Override your serializer_class</p> Source code in <code>drf_payments/mixins.py</code> <pre><code>class PaymentCallbackView(generics.CreateAPIView):\n\"\"\"Override your serializer_class\"\"\"\n\n    serializer_class = PaymentCallbackSerializerMixin\n    permission_classes = (AllowAny,)\n</code></pre>"},{"location":"drf/drf/#paymentcallbackserializermixin","title":"PaymentCallbackSerializerMixin","text":"<p>Serializer that contains all business logic related to processing webhook</p> <p>         Bases: <code>serializers.Serializer</code></p> <p>StripeCheckoutProvider</p> <p>success stripe checkout session send 4 events:</p> <p>payment_intent.created</p> <p>charge.succeeded</p> <p>payment_intent.succeeded</p> <p>checkout.session.completed</p> <p>We will capture checkout.session.completed and modify our payment model data. example data: ``` StripeProvider</p> <p>Send 3 events:</p> <p>payment_intent.created</p> <p>charge.succeeded</p> <p>payment_intent.succeeded</p> <p>PayPalProvider</p> <p>Send event</p> <p>CHECKOUT.ORDER.APPROVED</p> Source code in <code>drf_payments/mixins.py</code> <pre><code>class PaymentCallbackSerializerMixin(serializers.Serializer):\n\"\"\"\n    StripeCheckoutProvider\n\n    success stripe checkout session send 4 events:\n\n    payment_intent.created\n\n    charge.succeeded\n\n    payment_intent.succeeded\n\n    checkout.session.completed\n\n    We will capture checkout.session.completed and modify our payment model data.\n    example data:\n    ```\n    StripeProvider\n\n    Send 3 events:\n\n    payment_intent.created\n\n    charge.succeeded\n\n    payment_intent.succeeded\n\n    PayPalProvider\n\n    Send event\n\n    CHECKOUT.ORDER.APPROVED\n\n\n    \"\"\"\n\n    def create(self, validated_data):\n        event = self.context.get(\"request\", None).data\n        # * Stripe checkout session hook\n        if event.get(\"type\") == \"checkout.session.completed\":\n            payment_id = event[\"data\"][\"object\"].get(\"client_reference_id\")\n            status = event[\"data\"][\"object\"][\"payment_status\"]\n            if status == \"paid\":\n                try:\n                    self._change_payment_status(payment_id, event, \"session\")\n                except Exception as e:\n                    raise serializers.ValidationError(f\"Payment with id {payment_id} not found\") from e\n        # * Stripe payment  hook\n        if event.get(\"type\") == \"payment_intent.succeeded\":\n            payment_id = event[\"data\"][\"object\"].get(\"metadata\", {}).get(\"order_no\", None)\n            status = event[\"data\"][\"object\"][\"status\"]\n            if status == \"succeeded\":\n                try:\n                    self._change_payment_status(payment_id, event, \"payment_intend\")\n                except Exception as e:\n                    raise serializers.ValidationError(f\"Payment with id {payment_id} not found\") from e\n        # * Paypal hook\n        if event.get(\"event_type\") == \"CHECKOUT.ORDER.APPROVED\":\n            payment_id = event.get(\"resource\", {}).get(\"id\")\n            status = event.get(\"resource\", {}).get(\"status\")\n            # * Upon checkout approval we change status and capture payment\n            if status == \"APPROVED\":\n                try:\n                    payment = get_payment_model().objects.get(transaction_id=payment_id)\n                    payment.status = PaymentStatus.CONFIRMED.name\n                    payment.extra_data[\"order\"] = event.get(\"resource\", {})\n                    payment.save(update_fields=[\"status\", \"extra_data\"])\n                    get_payment_service(\"paypal\").capture(payment)\n                except Exception as e:\n                    raise serializers.ValidationError(f\"Payment with id {payment_id} not found\") from e\n        # * Braintree webhook\n        if \"bt_signature\" in event:\n            bt = get_payment_service(\"braintree\")\n            try:\n                result = bt.service.webhook_notification.parse(event[\"bt_signature\"], event[\"bt_payload\"])\n            except Exception as e:\n                raise serializers.ValidationError(f\"Can't parse event {e}\") from e\n            try:\n                payment = get_payment_model().objects.get(transaction_id=result.transaction.id)\n                data = bt._serialize(bt.service.transaction.find(result.transaction.id).__dict__)\n                payment.extra_data[\"transaction\"] = data\n                payment.status = PaymentStatus.CONFIRMED.name\n                payment.save(update_fields=[\"status\", \"extra_data\"])\n            except Exception as e:\n                raise serializers.ValidationError(f\"Can't find payment {result.transaction.id}\") from e\n        return validated_data\n\n    @staticmethod\n    def _change_payment_status(payment_id, event, data):\n        payment = get_payment_model().objects.get(pk=payment_id)\n        payment.status = PaymentStatus.CONFIRMED.name\n        payment.extra_data[data] = event[\"data\"][\"object\"]\n        payment.save(update_fields=[\"status\", \"extra_data\"])\n\n    def to_representation(self, instance):\n        return {\"message\": \"Your payment was successful\"}\n</code></pre>"},{"location":"drf/drf/#paymentsettingsview","title":"PaymentSettingsView","text":"<p>Public view to return payment settings if needed on client part (currently only braintree provider)</p> <p>         Bases: <code>views.APIView</code></p> Source code in <code>drf_payments/mixins.py</code> <pre><code>class PaymentSettingsView(views.APIView):\n    permission_classes = (AllowAny,)\n\n    def get(self, request, *args, **kwargs):\n        try:\n            token = get_payment_service(\"braintree\").get_client_token()\n        except Exception:\n            return Response(status=400)\n\n        return Response(status=200, data={\"client_token\": token})\n</code></pre>"},{"location":"drf/drf/#paymentviewmixin","title":"PaymentViewMixin","text":"<p>View that handles creation of payment model, and adds refund action</p> <p>         Bases: <code>ModelViewSet</code></p> <p>Add custom method for payment instance based on variant</p> Source code in <code>drf_payments/mixins.py</code> <pre><code>class PaymentViewMixin(ModelViewSet):\n    \"Add custom method for payment instance based on variant\"\n    serializer_class = PaymentSerializerMixin\n    queryset = get_payment_model().objects.all()\n\n    @action(detail=True, methods=[\"POST\"])\n    def refund(self, request, pk):\n        payment = get_object_or_404(get_payment_model())\n        try:\n            get_payment_service(payment.variant).refund(payment)\n        except Exception as e:\n            return Response(data={\"error\": str(e)}, status=400)\n        return Response(data=self.serializer_class(payment).data, status=200)\n</code></pre>"},{"location":"drf/drf/#paymentserializermixin","title":"PaymentSerializerMixin","text":"<p>Serializer to handle payment on model instance creation</p> <p>         Bases: <code>serializers.ModelSerializer</code></p> <p>PaymentSerializerMixin</p> <p>Should be used on your payment model, will handle payment related flow on creation of Payment Instance</p> Source code in <code>drf_payments/mixins.py</code> <pre><code>class PaymentSerializerMixin(serializers.ModelSerializer):\n\"\"\"PaymentSerializerMixin\n\n    Should be used on your payment model, will handle payment related flow on creation of Payment Instance\n\n    \"\"\"\n\n    card = serializers.CharField(required=False, write_only=True)\n    card_expiration = serializers.CharField(required=False, write_only=True)\n    card_cvv = serializers.CharField(required=False, write_only=True)\n\n    class Meta:\n        model = get_payment_model()\n        fields = \"__all__\"\n        read_only_fields = [\"status\", \"extra_data\"]\n\n    def validate(self, attrs):\n        # * In case of authorizenet provider we must provide card data\n        if self.initial_data.get(\"variant\") == \"authorizenet\" and all(\n            key not in attrs for key in [\"card\", \"card_cvv\", \"card_expiration\"]\n        ):\n            raise serializers.ValidationError(\"Card, card_expiration, card_cvv are required when using authorizenet\")\n        return super().validate(attrs)\n\n    def create(self, validated_data):\n        # * Move card data to extra data field in case of authorizenet provider\n        if validated_data[\"variant\"] == \"authorizenet\":\n            validated_data[\"extra_data\"] = {\n                \"card\": {\n                    \"x_card_num\": validated_data.pop(\"card\"),\n                    \"x_card_code\": validated_data.pop(\"card_cvv\"),\n                    \"x_exp_date\": validated_data.pop(\"card_expiration\"),\n                },\n            }\n        instance = super().create(validated_data)\n        service = get_payment_service(instance.variant)\n        service.process_payment(instance)\n        return instance\n\n    # ? Adding payment url from extra_data\n    def to_representation(self, instance):\n\"\"\"\n        Override the default representation of the instance object to include the payment urls\n        \"\"\"\n        data = super().to_representation(instance)\n        if instance.variant == \"stripe\" and isinstance(\n            get_payment_service(instance.variant),\n            drf_payments.stripe.StripeCheckoutProvider,\n        ):\n            data[\"url\"] = instance.extra_data[\"session\"][\"url\"]\n        # * In case of paypal we return url for checkout form\n        if instance.variant == \"paypal\" and isinstance(\n            get_payment_service(instance.variant),\n            drf_payments.paypal.PaypalProvider,\n        ):\n            data[\"url\"] = instance.extra_data[\"order\"][\"links\"][1][\"href\"]\n        return data\n</code></pre>"},{"location":"drf/drf/#drf_payments.mixins.PaymentSerializerMixin.to_representation","title":"<code>to_representation(instance)</code>","text":"<p>Override the default representation of the instance object to include the payment urls</p> Source code in <code>drf_payments/mixins.py</code> <pre><code>def to_representation(self, instance):\n\"\"\"\n    Override the default representation of the instance object to include the payment urls\n    \"\"\"\n    data = super().to_representation(instance)\n    if instance.variant == \"stripe\" and isinstance(\n        get_payment_service(instance.variant),\n        drf_payments.stripe.StripeCheckoutProvider,\n    ):\n        data[\"url\"] = instance.extra_data[\"session\"][\"url\"]\n    # * In case of paypal we return url for checkout form\n    if instance.variant == \"paypal\" and isinstance(\n        get_payment_service(instance.variant),\n        drf_payments.paypal.PaypalProvider,\n    ):\n        data[\"url\"] = instance.extra_data[\"order\"][\"links\"][1][\"href\"]\n    return data\n</code></pre>"},{"location":"getting_started/installation/","title":"Installation","text":"<ul> <li><code>pip install drf-payments</code></li> <li>Add to <code>INSTALLED_APPS</code></li> </ul> <pre><code>INSTALLED_APPS = [\n    \"django.contrib.admin\",\n    \"django.contrib.auth\",\n    \"django.contrib.contenttypes\",\n    \"django.contrib.sessions\",\n    \"django.contrib.messages\",\n    \"django.contrib.staticfiles\",\n    \"drf_payments\",\n    ...\n]\n</code></pre> <ul> <li>Add callback url</li> </ul> <pre><code>from django.contrib import admin\nfrom django.urls import include, path\n\nurlpatterns = [\n    path(\"admin/\", admin.site.urls),\n    ...\n    path(\"drf-payments/\", include(\"drf_payments.urls\")),\n]\n</code></pre> <ul> <li>Provide required settings</li> </ul> <pre><code>PAYMENT_MODEL = \"stripe_checkout.StripeCheckoutPayment\"\nPAYMENT_CALLBACK_URL = \"http://localhost:8000/drf-payments/callback/\"\nPAYMENT_SUCCESS_URL = \"http://localhost:3000/payments/success/\"\nPAYMENT_FAILURE_URL = \"http://localhost:3000/payments/failure/\"\n\nPAYMENT_VARIANTS = {\n    \"stripe\": (\n        \"drf_payments.stripe.StripeCheckoutProvider\",\n        {\n            \"secret_key\": os.environ.get(\"STRIPE_SECRET_KEY\"),\n            \"public_key\": os.environ.get(\"STRIPE_PUBLIC_KEY\"),\n        },\n    ),\n    \"paypal\": (\n        \"drf_payments.paypal.PaypalProvider\",\n        {\n            \"client_id\": os.environ.get(\"PAYPAL_CLIENT_ID\"),\n            \"secret\": os.environ.get(\"PAYPAL_SECRET_KEY\"),\n            \"endpoint\": os.environ.get(\"PAYPAL_URL\", \"https://api.sandbox.paypal.com\"),\n        },\n    ),\n}\n</code></pre>"},{"location":"getting_started/usage/","title":"Usage","text":"<p>For usage you can check example implementation in repo</p> <ul> <li>Inherit <code>drf_payments.models.BasePayment</code> model in your app</li> </ul> <pre><code>from drf_payments.models import BasePayment\n\nclass StripeChargePayment(BasePayment):\n    ...\n\n    class Meta:\n        db_table = \"stripe_charge\"\n</code></pre> <ul> <li>Use <code>drf_payments.mixins.PaymentViewMixin</code> in view that handles your payment model</li> </ul> <pre><code>from rest_framework.routers import SimpleRouter\n\nfrom drf_payments.mixins import PaymentViewMixin\n\napp_name = \"shop\"\n\nrouter = SimpleRouter()\nrouter.register(\"payment\", PaymentViewMixin, basename=\"payment\")\n\nurlpatterns = [*router.urls]\n</code></pre> <ul> <li>Point your payments events to endpoint from settings <code>PAYMENT_CALLBACK_URL</code></li> </ul> <p>For more info please check <code>example</code> app inside repository</p>"},{"location":"providers/authorizenet/","title":"Authorizenet","text":"<p>Create payment via Authorize.net</p>"},{"location":"providers/authorizenet/#settings-for-provider","title":"Settings for provider","text":"<pre><code>PAYMENT_VARIANTS = {\n    \"braintree\": (\n        \"drf_payments.braintree.BraintreeProvider\",\n        {\n            \"merchant_id\": os.environ.get(\"BRAINTREE_MERCHANT_ID\"),\n            \"public_key\": os.environ.get(\"BRAINTREE_PUBLIC_KEY\"),\n            \"private_key\": os.environ.get(\"BRAINTREE_PRIVATE_KEY\"),\n            \"sandbox\": os.environ.get(\"BRAINTREE_SANDBOX\", True),\n        },\n    ),\n    }\n</code></pre>"},{"location":"providers/authorizenet/#authorizenetprovider","title":"AuthorizeNetProvider","text":"<p>         Bases: <code>BasicProvider</code></p> <p>AuthorizeNetProvider</p> <p>AuthorizeNetProvider it handles:</p> <ul> <li>Creating a payment</li> <li>Immediately change payment status due to missing webhook in sanbox mode</li> </ul> <p>Parameters:</p> Name Type Description Default <code>login_id</code> <code>string</code> <p>Your authorizenet login_id</p> required <code>transaction_key</code> <code>string</code> <p>Your authorizenet transaction_key</p> required <code>endpoint</code> <code>string</code> <p>Your authorizenet endpoint</p> <code>'https://test.authorize.net/gateway/transact.dll'</code> Source code in <code>drf_payments/authorizenet/__init__.py</code> <pre><code>class AuthorizeNetProvider(BasicProvider):\n\"\"\"AuthorizeNetProvider\n\n    AuthorizeNetProvider\n    it handles:\n\n    - Creating a payment\n    - Immediately change payment status due to missing webhook in sanbox mode\n\n    Args:\n        login_id (string): Your authorizenet login_id\n        transaction_key (string): Your authorizenet transaction_key\n        endpoint (string): Your authorizenet endpoint\n    \"\"\"\n\n    def __init__(self, login_id, transaction_key, endpoint=\"https://test.authorize.net/gateway/transact.dll\", **kwargs):\n        self.login_id = login_id\n        self.transaction_key = transaction_key\n        self.endpoint = endpoint\n\n    def process_payment(self, payment):\n\"\"\"process_payment\n\n        Create payment and immediately change  status if status OK\n\n        Args:\n            payment (payment): Payment instance\n        \"\"\"\n        # sourcery skip: dict-assign-update-to-union\n        # * Due to official SDK don't support python 3.10 onwards  manual implementation required\n        data = {\n            \"x_amount\": payment.total,\n            \"x_refId\": payment.id,\n            \"x_currency_code\": payment.currency,\n            \"x_description\": payment.description,\n            \"x_first_name\": payment.billing_first_name,\n            \"x_last_name\": payment.billing_last_name,\n            \"x_address\": f\"{payment.billing_address_1}, {payment.billing_address_2}\",\n            \"x_city\": payment.billing_city,\n            \"x_zip\": payment.billing_postcode,\n            \"x_country\": payment.billing_country_area,\n            \"x_customer_ip\": payment.customer_ip_address,\n            \"x_login\": self.login_id,\n            \"x_tran_key\": self.transaction_key,\n            \"x_delim_data\": True,\n            \"x_delim_char\": \"|\",\n            \"x_method\": \"CC\",\n            \"x_type\": \"AUTH_CAPTURE\",\n        }\n        # *  Append card data to payload\n        data.update(payment.extra_data[\"card\"])\n        resp = requests.post(self.endpoint, data=data)\n        data = resp.text.split(\"|\")\n        try:\n            message = data[3]\n        except IndexError as e:\n            raise PaymentError(\"Wrong response\") from e\n        status = \"error\"\n        if resp.ok and RESPONSE_STATUS.get(data[0], False):\n            status = RESPONSE_STATUS.get(data[0], status)\n            payment.transaction_id = data[6]\n            payment.status = status.name\n            payment.save(update_fields=[\"transaction_id\", \"status\"])\n        else:\n            payment.status = PaymentStatus.ERROR.name\n            payment.extra_data[\"errors\"] = [message]\n            payment.save(update_fields=[\"status\", \"extra_data\"])\n</code></pre>"},{"location":"providers/authorizenet/#drf_payments.authorizenet.AuthorizeNetProvider.process_payment","title":"<code>process_payment(payment)</code>","text":"<p>process_payment</p> <p>Create payment and immediately change  status if status OK</p> <p>Parameters:</p> Name Type Description Default <code>payment</code> <code>payment</code> <p>Payment instance</p> required Source code in <code>drf_payments/authorizenet/__init__.py</code> <pre><code>def process_payment(self, payment):\n\"\"\"process_payment\n\n    Create payment and immediately change  status if status OK\n\n    Args:\n        payment (payment): Payment instance\n    \"\"\"\n    # sourcery skip: dict-assign-update-to-union\n    # * Due to official SDK don't support python 3.10 onwards  manual implementation required\n    data = {\n        \"x_amount\": payment.total,\n        \"x_refId\": payment.id,\n        \"x_currency_code\": payment.currency,\n        \"x_description\": payment.description,\n        \"x_first_name\": payment.billing_first_name,\n        \"x_last_name\": payment.billing_last_name,\n        \"x_address\": f\"{payment.billing_address_1}, {payment.billing_address_2}\",\n        \"x_city\": payment.billing_city,\n        \"x_zip\": payment.billing_postcode,\n        \"x_country\": payment.billing_country_area,\n        \"x_customer_ip\": payment.customer_ip_address,\n        \"x_login\": self.login_id,\n        \"x_tran_key\": self.transaction_key,\n        \"x_delim_data\": True,\n        \"x_delim_char\": \"|\",\n        \"x_method\": \"CC\",\n        \"x_type\": \"AUTH_CAPTURE\",\n    }\n    # *  Append card data to payload\n    data.update(payment.extra_data[\"card\"])\n    resp = requests.post(self.endpoint, data=data)\n    data = resp.text.split(\"|\")\n    try:\n        message = data[3]\n    except IndexError as e:\n        raise PaymentError(\"Wrong response\") from e\n    status = \"error\"\n    if resp.ok and RESPONSE_STATUS.get(data[0], False):\n        status = RESPONSE_STATUS.get(data[0], status)\n        payment.transaction_id = data[6]\n        payment.status = status.name\n        payment.save(update_fields=[\"transaction_id\", \"status\"])\n    else:\n        payment.status = PaymentStatus.ERROR.name\n        payment.extra_data[\"errors\"] = [message]\n        payment.save(update_fields=[\"status\", \"extra_data\"])\n</code></pre>"},{"location":"providers/braintree/","title":"Braintree","text":"<p>Create Braintree payment</p>"},{"location":"providers/braintree/#settings-for-provider","title":"Settings for provider","text":"<pre><code>PAYMENT_VARIANTS = {\n    \"braintree\": (\n        \"drf_payments.braintree.BraintreeProvider\",\n        {\n            \"merchant_id\": os.environ.get(\"BRAINTREE_MERCHANT_ID\"),\n            \"public_key\": os.environ.get(\"BRAINTREE_PUBLIC_KEY\"),\n            \"private_key\": os.environ.get(\"BRAINTREE_PRIVATE_KEY\"),\n            \"sandbox\": os.environ.get(\"BRAINTREE_SANDBOX\", True),\n        },\n    ),\n    }\n</code></pre>"},{"location":"providers/braintree/#braintreeprovider","title":"BraintreeProvider","text":"<p>         Bases: <code>BasicProvider</code></p> <p>BraintreeProvider</p> <p>BraintreeProvider it handles:</p> <ul> <li> <p>Creating a Checkout Session</p> </li> <li> <p>Refunding payment</p> </li> <li> <p>Process payment confirmation with callback</p> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>merchant_id</code> <code>string</code> <p>Your braintree secret_key</p> required <code>public_key</code> <code>string</code> <p>Your braintree public_key</p> required <code>private_key</code> <code>string</code> <p>Your braintree private_key</p> required <code>sandbox</code> <code>bool</code> <p>Production or sandbox environment</p> required Source code in <code>drf_payments/braintree/__init__.py</code> <pre><code>class BraintreeProvider(BasicProvider):\n\"\"\"BraintreeProvider\n\n    BraintreeProvider\n    it handles:\n\n    - Creating a Checkout Session\n\n    - Refunding payment\n\n    - Process payment confirmation with callback\n\n    Args:\n        merchant_id (string): Your braintree secret_key\n        public_key (string): Your braintree public_key\n        private_key (string): Your braintree private_key\n        sandbox (bool): Production or sandbox environment\n    \"\"\"\n\n    def __init__(self, merchant_id, public_key, private_key, sandbox, **kwargs):\n        super().__init__(**kwargs)\n\n        if sandbox:\n            self.service = braintree.BraintreeGateway(\n                braintree.Configuration(\n                    braintree.Environment.Sandbox,\n                    merchant_id=merchant_id,\n                    public_key=public_key,\n                    private_key=private_key,\n                ),\n            )\n        else:\n            self.service = braintree.BraintreeGateway(\n                braintree.Configuration(\n                    braintree.Environment.Production,\n                    merchant_id=merchant_id,\n                    public_key=public_key,\n                    private_key=private_key,\n                ),\n            )\n\n    def process_payment(self, payment):\n\"\"\"process_payment\n\n        Process payment, require `payment_method_nonce` that should be generated on client side and\n        passed in payment.transaction_id\n        upon creation\n\n        Args:\n            payment (payment): Payment instance\n        \"\"\"\n        payment_method = payment.transaction_id\n        try:\n            result = self.service.transaction.sale(\n                {\n                    \"amount\": str(float(payment.total)),\n                    \"payment_method_nonce\": payment_method,\n                    \"options\": {\"submit_for_settlement\": True},\n                },\n            )\n        except Exception as e:\n            raise PaymentError(\"Can't process payment\") from e\n\n        data = self._serialize(result.transaction.__dict__)\n        payment.transaction_id = result.transaction.id\n        payment.extra_data[\"transaction\"] = data\n        payment.save(update_fields=[\"extra_data\", \"transaction_id\"])\n\n    def refund(self, payment, amount=None):\n\"\"\"refund\n\n        Refund payment instance\n\n        Args:\n            payment (payment): Your payment instance\n            amount (int, optional): Amount to refund. Defaults to None.\n\n        \"\"\"\n        if payment.status == PaymentStatus.CONFIRMED.name:\n            try:\n                result = self.service.transaction.refund(payment.transaction_id)\n                if isinstance(result, braintree.ErrorResult):\n                    raise PaymentError(\n                        f\"Can't process refund: {result.message}\",\n                    )  # pragma no cover sdk don't provide ErrorResult mock\n                payment.status = PaymentStatus.REFUNDED.name\n                payment.save(update_fields=[\"status\"])\n                return\n            except Exception as e:\n                raise PaymentError(\"Can't process refund\") from e\n        raise PaymentError(\"Only Confirmed payments can be refunded\")\n\n    @staticmethod\n    def _serialize(data) -&gt; dict:\n\"\"\"_serialize\n        Helper method to serializer braintree sdk objects.\n        sdk still don't provide convenient method to extract json object, so it will be done here\n        https://github.com/braintree/braintree_python/issues/137\n        \"\"\"\n        skip_fields = [\n            \"_setattrs\",\n            \"disbursement_details\",\n            \"descriptor\",\n            \"status_history\",\n            \"gateway\",\n            \"billing_details\",\n            \"credit_card_details\",\n            \"shipping_details\",\n            \"subscription_details\",\n            \"customer_details\",\n        ]\n        result = {key: item for key, item in data.items() if key not in skip_fields}\n        result[\"amount\"] = str(result[\"amount\"])\n        result[\"created_at\"] = str(result[\"created_at\"])\n        result[\"updated_at\"] = str(result[\"updated_at\"])\n        result[\"authorization_expires_at\"] = str(result[\"authorization_expires_at\"])\n        return result\n\n    def get_client_token(self):\n\"\"\"get_client_token\n\n        Generate client token that should be used on FE for creating payment nonce\n        \"\"\"\n        try:\n            token = self.service.client_token.generate()\n        except Exception:\n            return None\n        return token\n</code></pre>"},{"location":"providers/braintree/#drf_payments.braintree.BraintreeProvider.get_client_token","title":"<code>get_client_token()</code>","text":"<p>get_client_token</p> <p>Generate client token that should be used on FE for creating payment nonce</p> Source code in <code>drf_payments/braintree/__init__.py</code> <pre><code>def get_client_token(self):\n\"\"\"get_client_token\n\n    Generate client token that should be used on FE for creating payment nonce\n    \"\"\"\n    try:\n        token = self.service.client_token.generate()\n    except Exception:\n        return None\n    return token\n</code></pre>"},{"location":"providers/braintree/#drf_payments.braintree.BraintreeProvider.process_payment","title":"<code>process_payment(payment)</code>","text":"<p>process_payment</p> <p>Process payment, require <code>payment_method_nonce</code> that should be generated on client side and passed in payment.transaction_id upon creation</p> <p>Parameters:</p> Name Type Description Default <code>payment</code> <code>payment</code> <p>Payment instance</p> required Source code in <code>drf_payments/braintree/__init__.py</code> <pre><code>def process_payment(self, payment):\n\"\"\"process_payment\n\n    Process payment, require `payment_method_nonce` that should be generated on client side and\n    passed in payment.transaction_id\n    upon creation\n\n    Args:\n        payment (payment): Payment instance\n    \"\"\"\n    payment_method = payment.transaction_id\n    try:\n        result = self.service.transaction.sale(\n            {\n                \"amount\": str(float(payment.total)),\n                \"payment_method_nonce\": payment_method,\n                \"options\": {\"submit_for_settlement\": True},\n            },\n        )\n    except Exception as e:\n        raise PaymentError(\"Can't process payment\") from e\n\n    data = self._serialize(result.transaction.__dict__)\n    payment.transaction_id = result.transaction.id\n    payment.extra_data[\"transaction\"] = data\n    payment.save(update_fields=[\"extra_data\", \"transaction_id\"])\n</code></pre>"},{"location":"providers/braintree/#drf_payments.braintree.BraintreeProvider.refund","title":"<code>refund(payment, amount=None)</code>","text":"<p>refund</p> <p>Refund payment instance</p> <p>Parameters:</p> Name Type Description Default <code>payment</code> <code>payment</code> <p>Your payment instance</p> required <code>amount</code> <code>int</code> <p>Amount to refund. Defaults to None.</p> <code>None</code> Source code in <code>drf_payments/braintree/__init__.py</code> <pre><code>def refund(self, payment, amount=None):\n\"\"\"refund\n\n    Refund payment instance\n\n    Args:\n        payment (payment): Your payment instance\n        amount (int, optional): Amount to refund. Defaults to None.\n\n    \"\"\"\n    if payment.status == PaymentStatus.CONFIRMED.name:\n        try:\n            result = self.service.transaction.refund(payment.transaction_id)\n            if isinstance(result, braintree.ErrorResult):\n                raise PaymentError(\n                    f\"Can't process refund: {result.message}\",\n                )  # pragma no cover sdk don't provide ErrorResult mock\n            payment.status = PaymentStatus.REFUNDED.name\n            payment.save(update_fields=[\"status\"])\n            return\n        except Exception as e:\n            raise PaymentError(\"Can't process refund\") from e\n    raise PaymentError(\"Only Confirmed payments can be refunded\")\n</code></pre>"},{"location":"providers/paypal/","title":"Paypal","text":"<p>Create Paypal checkout session to handle payment</p>"},{"location":"providers/paypal/#settings-for-provider","title":"Settings for provider","text":"<pre><code>PAYMENT_VARIANTS = {\n    \"paypal\": (\n        \"drf_payments.paypal.PaypalProvider\",\n        {\n            \"client_id\": os.environ.get(\"PAYPAL_CLIENT_ID\"),\n            \"secret\": os.environ.get(\"PAYPAL_SECRET_KEY\"),\n            \"endpoint\": os.environ.get(\"PAYPAL_URL\", \"https://api.sandbox.paypal.com\"),\n        },\n    ),\n    }\n</code></pre>"},{"location":"providers/paypal/#paypalprovider","title":"PaypalProvider","text":"<p>         Bases: <code>BasicProvider</code></p> <p>PaypalProvider</p> <p>it handles:</p> <ul> <li> <p>Creating a Checkout Session</p> </li> <li> <p>Refunding payment</p> </li> <li> <p>Process payment confirmation with callback</p> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>string</code> <p>Your paypal client_id</p> required <code>secret_key</code> <code>string</code> <p>Your paypal secret_key</p> required <code>endpoint</code> <code>url</code> <p>Paypal endpoint sanbox or production</p> required Source code in <code>drf_payments/paypal/__init__.py</code> <pre><code>class PaypalProvider(BasicProvider):\n\"\"\"PaypalProvider\n\n\n    it handles:\n\n    - Creating a Checkout Session\n\n    - Refunding payment\n\n    - Process payment confirmation with callback\n\n    Args:\n        client_id (string): Your paypal client_id\n        secret_key (string): Your paypal secret_key\n        endpoint (url): Paypal endpoint sanbox or production\n    \"\"\"\n\n    def __init__(self, client_id, secret_key, endpoint, **kwargs):\n        super().__init__(**kwargs)\n        self.client_id = client_id\n        self.secret_key = secret_key\n        self.endpoint = endpoint\n\n    def process_payment(self, payment):\n\"\"\"process_payment\n\n        Process payment instance via PaypalProvider\n\n        Args:\n            payment (payment): Your app payment instance\n\n        \"\"\"\n        if payment.transaction_id:\n            raise PaymentError(\"This payment has already been processed.\")\n        token = self._create_token()\n        payload = {\n            \"intent\": \"CAPTURE\",\n            \"application_context\": {\n                \"return_url\": settings.PAYMENT_SUCCESS_URL,\n                \"cancel_url\": settings.PAYMENT_FAILURE_URL,\n            },\n            \"purchase_units\": [\n                {\n                    \"amount\": {\n                        \"currency_code\": payment.currency,\n                        \"value\": float(payment.total),\n                    },\n                },\n            ],\n        }\n        try:\n            resp = requests.post(\n                f\"{self.endpoint}/v2/checkout/orders\",\n                headers={\"Authorization\": f\"Bearer {token}\"},\n                json=payload,\n            ).json()\n        except requests.exceptions.RequestException as e:\n            raise PaymentError(e) from e\n        payment.transaction_id = resp.get(\"id\")\n        payment.extra_data[\"order\"] = resp\n        payment.save(update_fields=[\"extra_data\", \"transaction_id\"])\n\n    def _create_token(self) -&gt; str:\n\"\"\"_create_token\n\n        Method for creating authorization token for PayPal requests\n\n        Returns:\n            str: _description_\n        \"\"\"\n        token = base64.b64encode(f\"{self.client_id}:{self.secret_key}\".encode(\"utf-8\")).decode(\"utf-8\")\n\n        if access_token := (\n            requests.post(\n                f\"{self.endpoint}/v1/oauth2/token\",\n                data={\"grant_type\": \"client_credentials\"},\n                headers={\"Authorization\": f\"Basic {token}\"},\n            )\n            .json()\n            .get(\"access_token\")\n        ):\n            return access_token\n        else:\n            raise PaymentError(\"Can't create token\")\n\n    def refund(self, payment, amount=None):\n\"\"\"refund\n\n        Refund payment instance\n\n        Args:\n            payment (payment): Your payment instance\n            amount (int, optional): Amount to refund. Defaults to None.\n\n        \"\"\"\n        if payment.status == PaymentStatus.CONFIRMED.name:\n            try:\n                capture = payment.extra_data[\"order\"][\"purchase_units\"][0][\"payments\"][\"captures\"][0][\"id\"]\n            except (IndexError, KeyError) as e:\n                raise PaymentError(\"Can't Refund, payment has not been captured yet\") from e\n            token = self._create_token()\n            resp = requests.post(\n                f\"{self.endpoint}/v2/payments/captures/{capture}/refund\",\n                headers={\"Authorization\": f\"Bearer {token}\"},\n                json={},\n            ).json()\n            payment.extra_data[\"order\"] = resp\n            payment.save(update_fields=[\"extra_data\"])\n            return\n        raise PaymentError(\"Only Confirmed payments can be refunded\")\n\n    def capture(self, payment):\n\"\"\"capture\n\n        Upon successful checkout we will capture funds to finalize payment and have ability to refund\n\n        Args:\n            payment (payment): Your payment\n        \"\"\"\n        token = self._create_token()\n        resp = requests.post(\n            f\"{self.endpoint}/v2/checkout/orders/{payment.transaction_id}/capture\",\n            headers={\"Authorization\": f\"Bearer {token}\"},\n            json={},\n        ).json()\n        payment.extra_data[\"order\"] = resp\n        payment.save(update_fields=[\"extra_data\"])\n</code></pre>"},{"location":"providers/paypal/#drf_payments.paypal.PaypalProvider.capture","title":"<code>capture(payment)</code>","text":"<p>capture</p> <p>Upon successful checkout we will capture funds to finalize payment and have ability to refund</p> <p>Parameters:</p> Name Type Description Default <code>payment</code> <code>payment</code> <p>Your payment</p> required Source code in <code>drf_payments/paypal/__init__.py</code> <pre><code>def capture(self, payment):\n\"\"\"capture\n\n    Upon successful checkout we will capture funds to finalize payment and have ability to refund\n\n    Args:\n        payment (payment): Your payment\n    \"\"\"\n    token = self._create_token()\n    resp = requests.post(\n        f\"{self.endpoint}/v2/checkout/orders/{payment.transaction_id}/capture\",\n        headers={\"Authorization\": f\"Bearer {token}\"},\n        json={},\n    ).json()\n    payment.extra_data[\"order\"] = resp\n    payment.save(update_fields=[\"extra_data\"])\n</code></pre>"},{"location":"providers/paypal/#drf_payments.paypal.PaypalProvider.process_payment","title":"<code>process_payment(payment)</code>","text":"<p>process_payment</p> <p>Process payment instance via PaypalProvider</p> <p>Parameters:</p> Name Type Description Default <code>payment</code> <code>payment</code> <p>Your app payment instance</p> required Source code in <code>drf_payments/paypal/__init__.py</code> <pre><code>def process_payment(self, payment):\n\"\"\"process_payment\n\n    Process payment instance via PaypalProvider\n\n    Args:\n        payment (payment): Your app payment instance\n\n    \"\"\"\n    if payment.transaction_id:\n        raise PaymentError(\"This payment has already been processed.\")\n    token = self._create_token()\n    payload = {\n        \"intent\": \"CAPTURE\",\n        \"application_context\": {\n            \"return_url\": settings.PAYMENT_SUCCESS_URL,\n            \"cancel_url\": settings.PAYMENT_FAILURE_URL,\n        },\n        \"purchase_units\": [\n            {\n                \"amount\": {\n                    \"currency_code\": payment.currency,\n                    \"value\": float(payment.total),\n                },\n            },\n        ],\n    }\n    try:\n        resp = requests.post(\n            f\"{self.endpoint}/v2/checkout/orders\",\n            headers={\"Authorization\": f\"Bearer {token}\"},\n            json=payload,\n        ).json()\n    except requests.exceptions.RequestException as e:\n        raise PaymentError(e) from e\n    payment.transaction_id = resp.get(\"id\")\n    payment.extra_data[\"order\"] = resp\n    payment.save(update_fields=[\"extra_data\", \"transaction_id\"])\n</code></pre>"},{"location":"providers/paypal/#drf_payments.paypal.PaypalProvider.refund","title":"<code>refund(payment, amount=None)</code>","text":"<p>refund</p> <p>Refund payment instance</p> <p>Parameters:</p> Name Type Description Default <code>payment</code> <code>payment</code> <p>Your payment instance</p> required <code>amount</code> <code>int</code> <p>Amount to refund. Defaults to None.</p> <code>None</code> Source code in <code>drf_payments/paypal/__init__.py</code> <pre><code>def refund(self, payment, amount=None):\n\"\"\"refund\n\n    Refund payment instance\n\n    Args:\n        payment (payment): Your payment instance\n        amount (int, optional): Amount to refund. Defaults to None.\n\n    \"\"\"\n    if payment.status == PaymentStatus.CONFIRMED.name:\n        try:\n            capture = payment.extra_data[\"order\"][\"purchase_units\"][0][\"payments\"][\"captures\"][0][\"id\"]\n        except (IndexError, KeyError) as e:\n            raise PaymentError(\"Can't Refund, payment has not been captured yet\") from e\n        token = self._create_token()\n        resp = requests.post(\n            f\"{self.endpoint}/v2/payments/captures/{capture}/refund\",\n            headers={\"Authorization\": f\"Bearer {token}\"},\n            json={},\n        ).json()\n        payment.extra_data[\"order\"] = resp\n        payment.save(update_fields=[\"extra_data\"])\n        return\n    raise PaymentError(\"Only Confirmed payments can be refunded\")\n</code></pre>"},{"location":"providers/stripe/","title":"Stripe","text":"<p>There is 2 stripe providers:</p> <ul> <li>StripeCheckoutProvider</li> <li>StripeProvider</li> </ul>"},{"location":"providers/stripe/#settings-for-provider","title":"Settings for provider","text":"<pre><code>PAYMENT_VARIANTS = {\n    \"stripe\": (\n        \"drf_payments.stripe.StripeCheckoutProvider\",\n        {\n            \"secret_key\": os.environ.get(\"STRIPE_SECRET_KEY\"),\n            \"public_key\": os.environ.get(\"STRIPE_PUBLIC_KEY\"),\n        },\n    ),\n    \"stripe\": (\n        \"drf_payments.stripe.StripeProvider\",\n        {\n            \"secret_key\": os.environ.get(\"STRIPE_SECRET_KEY\"),\n            \"public_key\": os.environ.get(\"STRIPE_PUBLIC_KEY\"),\n        },\n    ),\n    }\n</code></pre>"},{"location":"providers/stripe/#stripecheckoutprovider","title":"StripeCheckoutProvider","text":"<p>         Bases: <code>BasicProvider</code></p> <p>StripeCheckoutProvider</p> <p>StripeCheckoutProvider for Stripe Checkout payments it handles:</p> <ul> <li> <p>Creating a Checkout Session</p> </li> <li> <p>Refunding payment</p> </li> <li> <p>Process payment confirmation with callback</p> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>secret_key</code> <code>string</code> <p>Your stripe secret_key</p> required Source code in <code>drf_payments/stripe/__init__.py</code> <pre><code>class StripeCheckoutProvider(BasicProvider):\n\"\"\"StripeCheckoutProvider\n\n    StripeCheckoutProvider for Stripe Checkout payments\n    it handles:\n\n    - Creating a Checkout Session\n\n    - Refunding payment\n\n    - Process payment confirmation with callback\n\n    Args:\n        secret_key (string): Your stripe secret_key\n    \"\"\"\n\n    def __init__(self, secret_key, **kwargs):\n        super().__init__(**kwargs)\n        self.secret_key = secret_key\n\n    def process_payment(self, payment):\n\"\"\"process_payment\n\n        Process payment instance via StripeCheckoutProvider\n\n        Args:\n            payment (payment): Your app payment instance\n\n        \"\"\"\n        if payment.transaction_id:\n            raise PaymentError(\"This payment has already been processed.\")\n        stripe.api_key = self.secret_key\n        session_data = {\n            \"line_items\": self.get_line_items(payment),\n            \"mode\": \"payment\",\n            \"success_url\": payment.success_url,\n            \"cancel_url\": payment.failure_url,\n            \"client_reference_id\": payment.pk,\n        }\n        # Patch session with billing email if exists\n        if payment.billing_email:\n            session_data[\"customer_email\"] = payment.billing_email\n        try:\n            session = stripe.checkout.Session.create(**session_data)\n            payment.transaction_id = session.get(\"id\", None)\n            payment.extra_data[\"session\"] = session\n            payment.save(update_fields=[\"extra_data\", \"transaction_id\"])\n            return session\n\n        except stripe.error.StripeError as e:\n            raise PaymentError(e) from e\n\n    def refund(self, payment, amount=None):\n\"\"\"refund\n\n        Refund payment instance\n\n        Args:\n            payment (payment): Your payment instance\n            amount (int, optional): Amount to refund. Defaults to None.\n\n        \"\"\"\n        if payment.status == PaymentStatus.CONFIRMED.name:\n            to_refund = amount or payment.total\n            payment_intent = payment.extra_data.get(\"session\", {}).get(\"payment_intent\", None)\n            if not payment_intent:\n                raise PaymentError(\"Can't Refund, payment_intent does not exist\")\n            stripe.api_key = self.secret_key\n            try:\n                refund = stripe.Refund.create(\n                    payment_intent=payment_intent,\n                    amount=convert_amount(payment.currency, to_refund),\n                    reason=\"requested_by_customer\",\n                )\n            except stripe.error.StripeError as e:\n                raise PaymentError(e) from e\n            else:\n                payment.extra_data[\"refund\"] = refund\n                payment.status = PaymentStatus.REFUNDED.name\n                payment.save(update_fields=[\"extra_data\", \"status\"])\n\n                return convert_amount(payment.currency, to_refund)\n\n        raise PaymentError(\"Only Confirmed payments can be refunded\")\n\n    def get_line_items(self, payment):\n\"\"\"get_line_items\n\n        Construct `line_items` from payment\n\n        Args:\n            payment (payment): Your payment instance\n\n        \"\"\"\n        order_no = payment.pk\n        product_data = StripeProductData(name=f\"Order #{order_no}\")\n\n        price_data = StripePriceData(\n            currency=payment.currency.lower(),\n            unit_amount=convert_amount(payment.currency, payment.total),\n            product_data=product_data,\n        )\n        line_item = StripeLineItem(\n            quantity=1,\n            price_data=price_data,\n        )\n        return [asdict(line_item)]\n</code></pre>"},{"location":"providers/stripe/#drf_payments.stripe.StripeCheckoutProvider.get_line_items","title":"<code>get_line_items(payment)</code>","text":"<p>get_line_items</p> <p>Construct <code>line_items</code> from payment</p> <p>Parameters:</p> Name Type Description Default <code>payment</code> <code>payment</code> <p>Your payment instance</p> required Source code in <code>drf_payments/stripe/__init__.py</code> <pre><code>def get_line_items(self, payment):\n\"\"\"get_line_items\n\n    Construct `line_items` from payment\n\n    Args:\n        payment (payment): Your payment instance\n\n    \"\"\"\n    order_no = payment.pk\n    product_data = StripeProductData(name=f\"Order #{order_no}\")\n\n    price_data = StripePriceData(\n        currency=payment.currency.lower(),\n        unit_amount=convert_amount(payment.currency, payment.total),\n        product_data=product_data,\n    )\n    line_item = StripeLineItem(\n        quantity=1,\n        price_data=price_data,\n    )\n    return [asdict(line_item)]\n</code></pre>"},{"location":"providers/stripe/#drf_payments.stripe.StripeCheckoutProvider.process_payment","title":"<code>process_payment(payment)</code>","text":"<p>process_payment</p> <p>Process payment instance via StripeCheckoutProvider</p> <p>Parameters:</p> Name Type Description Default <code>payment</code> <code>payment</code> <p>Your app payment instance</p> required Source code in <code>drf_payments/stripe/__init__.py</code> <pre><code>def process_payment(self, payment):\n\"\"\"process_payment\n\n    Process payment instance via StripeCheckoutProvider\n\n    Args:\n        payment (payment): Your app payment instance\n\n    \"\"\"\n    if payment.transaction_id:\n        raise PaymentError(\"This payment has already been processed.\")\n    stripe.api_key = self.secret_key\n    session_data = {\n        \"line_items\": self.get_line_items(payment),\n        \"mode\": \"payment\",\n        \"success_url\": payment.success_url,\n        \"cancel_url\": payment.failure_url,\n        \"client_reference_id\": payment.pk,\n    }\n    # Patch session with billing email if exists\n    if payment.billing_email:\n        session_data[\"customer_email\"] = payment.billing_email\n    try:\n        session = stripe.checkout.Session.create(**session_data)\n        payment.transaction_id = session.get(\"id\", None)\n        payment.extra_data[\"session\"] = session\n        payment.save(update_fields=[\"extra_data\", \"transaction_id\"])\n        return session\n\n    except stripe.error.StripeError as e:\n        raise PaymentError(e) from e\n</code></pre>"},{"location":"providers/stripe/#drf_payments.stripe.StripeCheckoutProvider.refund","title":"<code>refund(payment, amount=None)</code>","text":"<p>refund</p> <p>Refund payment instance</p> <p>Parameters:</p> Name Type Description Default <code>payment</code> <code>payment</code> <p>Your payment instance</p> required <code>amount</code> <code>int</code> <p>Amount to refund. Defaults to None.</p> <code>None</code> Source code in <code>drf_payments/stripe/__init__.py</code> <pre><code>def refund(self, payment, amount=None):\n\"\"\"refund\n\n    Refund payment instance\n\n    Args:\n        payment (payment): Your payment instance\n        amount (int, optional): Amount to refund. Defaults to None.\n\n    \"\"\"\n    if payment.status == PaymentStatus.CONFIRMED.name:\n        to_refund = amount or payment.total\n        payment_intent = payment.extra_data.get(\"session\", {}).get(\"payment_intent\", None)\n        if not payment_intent:\n            raise PaymentError(\"Can't Refund, payment_intent does not exist\")\n        stripe.api_key = self.secret_key\n        try:\n            refund = stripe.Refund.create(\n                payment_intent=payment_intent,\n                amount=convert_amount(payment.currency, to_refund),\n                reason=\"requested_by_customer\",\n            )\n        except stripe.error.StripeError as e:\n            raise PaymentError(e) from e\n        else:\n            payment.extra_data[\"refund\"] = refund\n            payment.status = PaymentStatus.REFUNDED.name\n            payment.save(update_fields=[\"extra_data\", \"status\"])\n\n            return convert_amount(payment.currency, to_refund)\n\n    raise PaymentError(\"Only Confirmed payments can be refunded\")\n</code></pre>"},{"location":"providers/stripe/#stripeprovider","title":"StripeProvider","text":"<p>         Bases: <code>BasicProvider</code></p> <p>StripeProvider Creating payment based on <code>payment_method</code> created on FE part</p> <p>it handles:</p> <ul> <li> <p>Creating a payment intent</p> </li> <li> <p>Refunding payment</p> </li> <li> <p>Receiving payment confirmation with callback</p> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>secret_key</code> <code>string</code> <p>Your stripe secret_key</p> required <code>public_key</code> <code>string</code> <p>Your stripe public_key</p> required Source code in <code>drf_payments/stripe/__init__.py</code> <pre><code>class StripeProvider(BasicProvider):\n\"\"\"StripeProvider\n    Creating payment based on `payment_method` created on FE part\n\n    it handles:\n\n    - Creating a payment intent\n\n    - Refunding payment\n\n    - Receiving payment confirmation with callback\n\n    Args:\n        secret_key (string): Your stripe secret_key\n        public_key (string): Your stripe public_key\n    \"\"\"\n\n    def __init__(self, secret_key, public_key, **kwargs):\n        super().__init__(**kwargs)\n        self.secret_key = secret_key\n        self.public_key = public_key\n\n    def process_payment(self, payment):\n\"\"\"process_payment\n\n        Process payment, require `payment_method.id` that should be generated on client side and\n        passed in payment.transaction_id\n\n        Args:\n            payment (payment): Payment instance\n        \"\"\"\n        stripe.api_key = self.secret_key\n        # * Create payment intent with payment method generated on FE\n        intent_data = {\n            \"payment_method\": payment.transaction_id,\n            \"amount\": int(payment.total * 100),\n            \"currency\": payment.currency,\n            \"confirmation_method\": \"automatic\",\n            \"confirm\": True,\n            \"metadata\": {\"order_no\": payment.pk},\n        }\n        try:\n            payment_intent = stripe.PaymentIntent.create(**intent_data)\n        except stripe.error.StripeError as e:\n            raise PaymentError(e) from e\n        payment.extra_data[\"payment_intent\"] = payment_intent\n        # * Switching transaction id to payment intent_id\n        payment.transaction_id = payment_intent.get(\"id\", None)\n        payment.save(update_fields=[\"extra_data\", \"transaction_id\"])\n\n    def refund(self, payment, amount=None):\n\"\"\"refund\n\n        Refund payment instance\n\n        Args:\n            payment (payment): Your payment instance\n            amount (int, optional): Amount to refund. Defaults to None.\n\n        \"\"\"\n        if payment.status == PaymentStatus.CONFIRMED.name:\n            to_refund = amount or payment.total\n            payment_intent = payment.extra_data.get(\"payment_intent\", None).get(\"id\", None)\n            if not payment_intent:\n                raise PaymentError(\"Can't Refund, payment_intent does not exist\")\n            stripe.api_key = self.secret_key\n            try:\n                refund = stripe.Refund.create(\n                    payment_intent=payment_intent,\n                    amount=convert_amount(payment.currency, to_refund),\n                    reason=\"requested_by_customer\",\n                )\n            except stripe.error.StripeError as e:\n                raise PaymentError(e) from e\n            else:\n                payment.extra_data[\"refund\"] = refund\n                payment.status = PaymentStatus.REFUNDED.name\n                payment.save(update_fields=[\"extra_data\", \"status\"])\n                return convert_amount(payment.currency, to_refund)\n\n        raise PaymentError(\"Only Confirmed payments can be refunded\")\n</code></pre>"},{"location":"providers/stripe/#drf_payments.stripe.StripeProvider.process_payment","title":"<code>process_payment(payment)</code>","text":"<p>process_payment</p> <p>Process payment, require <code>payment_method.id</code> that should be generated on client side and passed in payment.transaction_id</p> <p>Parameters:</p> Name Type Description Default <code>payment</code> <code>payment</code> <p>Payment instance</p> required Source code in <code>drf_payments/stripe/__init__.py</code> <pre><code>def process_payment(self, payment):\n\"\"\"process_payment\n\n    Process payment, require `payment_method.id` that should be generated on client side and\n    passed in payment.transaction_id\n\n    Args:\n        payment (payment): Payment instance\n    \"\"\"\n    stripe.api_key = self.secret_key\n    # * Create payment intent with payment method generated on FE\n    intent_data = {\n        \"payment_method\": payment.transaction_id,\n        \"amount\": int(payment.total * 100),\n        \"currency\": payment.currency,\n        \"confirmation_method\": \"automatic\",\n        \"confirm\": True,\n        \"metadata\": {\"order_no\": payment.pk},\n    }\n    try:\n        payment_intent = stripe.PaymentIntent.create(**intent_data)\n    except stripe.error.StripeError as e:\n        raise PaymentError(e) from e\n    payment.extra_data[\"payment_intent\"] = payment_intent\n    # * Switching transaction id to payment intent_id\n    payment.transaction_id = payment_intent.get(\"id\", None)\n    payment.save(update_fields=[\"extra_data\", \"transaction_id\"])\n</code></pre>"},{"location":"providers/stripe/#drf_payments.stripe.StripeProvider.refund","title":"<code>refund(payment, amount=None)</code>","text":"<p>refund</p> <p>Refund payment instance</p> <p>Parameters:</p> Name Type Description Default <code>payment</code> <code>payment</code> <p>Your payment instance</p> required <code>amount</code> <code>int</code> <p>Amount to refund. Defaults to None.</p> <code>None</code> Source code in <code>drf_payments/stripe/__init__.py</code> <pre><code>def refund(self, payment, amount=None):\n\"\"\"refund\n\n    Refund payment instance\n\n    Args:\n        payment (payment): Your payment instance\n        amount (int, optional): Amount to refund. Defaults to None.\n\n    \"\"\"\n    if payment.status == PaymentStatus.CONFIRMED.name:\n        to_refund = amount or payment.total\n        payment_intent = payment.extra_data.get(\"payment_intent\", None).get(\"id\", None)\n        if not payment_intent:\n            raise PaymentError(\"Can't Refund, payment_intent does not exist\")\n        stripe.api_key = self.secret_key\n        try:\n            refund = stripe.Refund.create(\n                payment_intent=payment_intent,\n                amount=convert_amount(payment.currency, to_refund),\n                reason=\"requested_by_customer\",\n            )\n        except stripe.error.StripeError as e:\n            raise PaymentError(e) from e\n        else:\n            payment.extra_data[\"refund\"] = refund\n            payment.status = PaymentStatus.REFUNDED.name\n            payment.save(update_fields=[\"extra_data\", \"status\"])\n            return convert_amount(payment.currency, to_refund)\n\n    raise PaymentError(\"Only Confirmed payments can be refunded\")\n</code></pre>"}]}